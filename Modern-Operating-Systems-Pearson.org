* Modern Operating Systems-Pearson [0%]
** TODO 1 INTRODUCTION 介绍 [12%]
一个现代操作系统由一个或多个处理器，一些主要内存，磁盘，打印机，键盘，鼠标，显示器，网络接口，和各种其它输入输出设备组成。所有这些，一个复杂的系统。如果每个应用程序不得不去理解所有那些事情的工作细节，不会有代码能做到。此外，管理所有那些组件和很好的使用他们是极其具有挑战的工作。基于这些原因，计算机需要一个叫做操作系统的软件层，它的工作是提供用更好，更干净，更简单，更模型化的计算机并且管理刚刚提到的所有资源。操作系统是这本书的主题。

诸多读者有一些使用像Windows，Linux，FreeBSD，或者OS X等操作系统的经验，但是表象正在欺骗你。和用户交互的程序，通常基于文本时是它是 shell 和当 GUI时它使用图标，事实上不是操作系统的一部分，虽然它使用操作系统来工作。

一个简单的主要组件概览像图1-1.我们能看到在最底部的是硬件。硬件由芯片，电路板，磁盘，键盘，监视器，和相似的实际物体组成。在硬件上面是软件。许多计算机有两个操作模式：内核模式和用户模式。操作系统中，最基础的部分软件，运行在内核模式上（也被叫做管理模式）。在这个模式里它能完全访问所有硬件并且能执行任何机器能正确执行的指令。软件的其它部分运行在用户模式下，仅仅是机器指令的子集。尤其，那些控制机器或者IO操作的指令在用户模式下是禁止的。我们将通过这本书反复看到内核模式和用户模式的不同。它扮演一个重要的角色在操作系统怎么工作中。

用户接口程序，shell 或者 GUI，是用户模式软件中最低的一级，允许用户去启动其它的程序，像一个web浏览器，邮件阅读器或者音乐播放器。这些程序也是操作系统经常使用使用。

你操作系统的部署显示在图1-1.它跑在基本硬件并且提供所有其它软件的基础。

在操作系统和普通软件之间一个重要的不同是如果用户不喜欢一个特定的邮件阅读器，他是自由的选择一个不同的或者自己写一个；他不能写他自己的时钟代理，那是操作系统的一部分并且当用户试着去更改时被保护。

然而这个不同有时是模糊的在嵌入式系统（可能没有内核模式）或者解释式系统（像基于 java 的系统使用解释器，没有硬件去分割组件）。

虽然，在许多系统中有程序运行在用户模式下但是也帮助操作系统或者执行特殊的函数。例如，通常有一个程序允许用户去更改他们的密码。它不是操作系统的一部分并且不运行在内核模式，但是它无疑执行一个敏感的函数并且必须在某种途径上受到保护。在一些系统中，这个想法是极其传统的考虑到操作系统（比如文件系统）运行在用户空间里。在这样的系统中，画一个清晰的界线是困难的。所有运行在内核模式下的是操作系统的部分，但是一些程序运行在它的外部也可以说是它的一部分，或者至少接近有关系和它。

操作系统和用户程序的不同也来自于它们所处的位置。尤其它们是大型的复杂的长期存在的。一个像 Linux 或 Windows 的操作系统的核心源码级别在5百万行或者更多。想象一下这是什么意思，想象一下打印5百万行在书上，一本书每页50行并且1000页。显示一个操作系统需要1000本书，相当于一个书架。你能想象得到一个维护操作系统的工作，在第一天上班时老板带给你一个用代码做成的书架说：“去学习那些”。 并且这仅仅是在内核中运行的一部分。当必要的共享库被包含进来，Windows 超过7千万行或者10到20个书架。并且这去除了基本应用程序（像Window Explorer， Windows Media Player等等）。

现在它清楚了显示了为什么操作系统生命周期长-它们非常难写并且已经写过一个，所有者是不乐意抛弃它开始再写一个新的。作为代替，操作系统的演变周期相当长。 Windows 95/98/Me 基本上是一个操作系统并且 Windows NT/2000/XP/Vista/Windows 7 是不同的一个。它们对用户看起来一样是因为微软使 2000/XP/VISTA/7 的用户界面非常接近98.然而有非常好的原因为什么微软抛弃98. 我们将在第11部分学习window的时候知道。

除了 Windows， 另一个主要的我们将贯穿这本书的例子是UNIX和它的变种和克隆。它也进货了很多年，像从原生系统衍生出来的变种System V， Solaris和FressBSD，然而Linux是更好的替代，它非常接近UNIX并且并且高度兼容。我们将使用UNIX并且在第10部分了解Linux的细节。

在这个部分我们将短暂了解操作系统的几个关键点，包括它们是什么，它们的历史，种类，一些基本概念，和它们的构造。在后面的部分我们将有更多重要的关于细节的主题。

*** DONE 1.1 操作系统是什么
CLOSED: [2016-08-05 Fri 10:56]
操作系统是什么是很难下定义的，其中的一个说法是它是运行在核心模式上的软件-但这从来并不是永远正确的。部分问题是操作系统执行两个根本不相关的函数：提供应用程序代理硬件的抽象和管理硬件资源。 通过谁在做演讲，你可能听过相近的函数或者其它。让我们现在看下面的两个。
***** TODO 操作系统做为一个机器的扩展
许多在机器语言级别上计算机的结构是原始的和难以编程的，特别是输入输出。对于这个点上更具体的，考虑现代SATA硬盘被使用在很多计算机上。一本描述早期硬盘接口版本的书（2007）-超过450页。从那以后，接口已经改进很多次并且比2007年的时候更复杂。显然，没有一个正常的编程者会想深入到这个磁盘的硬件级别。 代替的是一块软件，叫做硬件驱动，深入到硬件并且提供一个接口去读写硬盘区块，不用管它的细节。操作系统包含许多控制IO设备的驱动。

但是这个对大多数程序级别太低了。基于这个原因，所有的操作系统也提供另一个使用磁盘的抽象：文件。使用这个抽象，程序可以建立，写入，读取文件，不用去了解硬件真实工作的细节。

这个抽象是管理所有这些复杂的关键。好的抽象可以使一个近乎不可能的任务变成两个可能的。首先是定义和实现抽象。第二是使用这些抽象去解决手上的问题。 一个几乎每个计算机用户能理解的抽象是文件，像上面提到的。它是有用的信息片断，像一个数码照片，保存邮件内容，歌曲，或者网页。它是更容易处理照片，邮件，歌曲，和网页比SATA磁盘的明细。操作系统的工作是建立好的抽象然后实现和管理建立的抽象。在本书中，我们将讨论大师关于抽象。它们是理解操作系统的关键。

这点如此重要以致于它被分进不同的单词里。对于所有使用Macintosh的工程师来说，硬件是丑陋的。真正的进程，内存，磁盘和其它设备是非常复杂和存在困难，棘手，怪异，多变的接口让人写软件去使用它们。有时存在适配复杂的老硬件。另一边它花费金钱。经常，硬件设计者不了解他们给软件导致了多大的麻烦。操作系统的主要任务之一是隐藏硬件和提供程序和它们的开发者漂亮，更干净，抽象的去工作。 操作系统要从丑陋为美丽。

你应该注意到操作系统的真正顾客是应用程序（通过应用程序开发者）。他们是真正深入操作系统和它的抽象的人。相比之下，最终用户了解的抽象由用户界面提供。命令行或者图形界面。当在用户界面由操作系统提供的抽象并不常见。关于这个相关的点，考虑普通Windows 桌面和命令行。 两个都是运行在Windows操作系统的程序和使用Windows提供的抽象。但是它们是非常不同的用户界面。同样，一个Linux运行GNOME 或者KDE看起来非常不同比一个linux用户工作在Xwindows系统下，但是下面的操作系统抽象是相同的。

这本书，我们将学习在细节上的应用程序抽象，但是比用户界面要小。 那是巨大的和重要的课题，但是只有一个关系到操作系统。
***** TODO 操作系统作为资源管理器
操作系统的概念做为应用程序的主要抽象是自上而下的显示。备选的，是从下而上，操作系统管理所有复杂系统的块。现代计算机有处理器，内存，计时器，磁盘，鼠标，网络接口，打印机和更多范围的其它设备。有自下而上的显示中，操作系统的工作是提供有级别的控制处理器，内存和IO设备，像程序希望他们那样。

现代操作系统允计多个程序在内存中并且同时运行。想象发生了什么如果三个程序运行在相同的计算机都试着去打印它们的输出到相同的打印机。 首先几行输出可能来之于程序1，下一个是程序2，然后是程序3，然后是4. 结果将是混乱的。操作系统能带来顺序通过缓存所有的输出在磁盘上的打印机。当一个程序完成时，操作系统从它被储存对打印磁盘文件拷贝它的输出，当此时其它的程序能继续产生更多输出，除了输出并不准备去打印。

当一个计算机有一个以上的用户时，对管理和保护内存，IO设备，和其它资源的需要是更多的，因为用户可能在其它方面使用另一个接口。 接下来， 用户经常需要分享不仅是硬件，还有信息。简短的说，这个操作系统的显示保持它的主任务是保持程序使用相应的资源，授予资源许可，用户账户，和在不同的程序和用户之间调解冲突。

资源管理包括复用资源在两个不同的路径：时间和这俚。 当一个资源是时间复用时，不同的程序或用户轮流使用它。 首先他们中的一个使用资源，然后另一个，等等。比如仅使用一个CPU并且多个程序想运行，操作系统首先分配CPU给一个程序，然后，它运行足够长的时间后，另一个程序开始使用CPU，然后另一个，最终第一个再次运行。决定资源是时间复用的-谁是下一个运行多长时间-是操作系统的任务。时间复用的另一个是共享打印机。当多个打印工作在一个简单的打印机上准备队列打印，决定哪个是下一个必须做出。

另一个路复用是空间复用。 轮流替换客户，每人得到资源的部分。 比如，主内存被几个运行中的程序分割，每一个居住在相同的时间。假设有足够的内存保持信多个程序，它更多的保持它们所有在内存中而不是它们中的一个，特别是它仅仅是需要全部的一个小函数。当然，这增加了公平保护等的债，并且它在操作系统层面上解决它们。另一个资源是磁盘。在许多系统中空间和保持哪个空间是谁使用是操作系统的任务。
*** TODO 1.2 操作系统的历史
操作系统已经进化了很多年。在接下来我们将简单的看几个闪光点。
*** TODO 1.3 计算机硬件浏览
*** TODO 1.4 操作系统动物园
*** TODO 1.5 操作系统概念
*** TODO 1.6 系统调用
*** TODO 1.7 操作系统构造
*** TODO 1.8 C的世界
** TODO 2 进程和线程 [0%] 
*** TODO 2.1 进程
*** TODO 2.2 线程
*** TODO 2.3 进程间通信
*** TODO 2.4 调度
*** TODO 2.5 传统IPC问题
*** TODO 2.6 在进程和线程上探索
*** TODO 2.7 总结
** TODO 3 内存管理
*** TODO 3.1 没有内存抽象
*** TODO 3.2 一个内存抽象：地址空间
*** TODO 3.3 虚拟内存
*** TODO 3.4 页替换算法
*** TODO 3.5 分页系统的问题设计
*** TODO 3.6 实现问题
*** TODO 3.7 分割
*** TODO 3.8 研究内存管理
*** TODO 3.9 总结
** TODO 4 文件系统
*** TODO 4.1 文件
*** TODO 4.2 目录
*** TODO 4.3 文件系统实现
*** TODO 4.4 文件系统管理和组织
*** TODO 4.5 文件系统例子
*** TODO 4.6 探索文件系统
*** TODO 4.7 总结
** TODO 5 输入/输出
*** TODO 1. I/O 硬件的原则
*** TODO 2. I/O 软件的原则
*** TODO 3. I/O 软件层
*** TODO 4. 磁盘
*** TODO 5. 时钟
*** TODO 6. 用户输入：键盘，鼠标，监听
*** TODO 7. 瘦客户端
*** TODO 8. 电源管理
*** TODO 9. 探索输入输出
*** TODO 10. 总结
** TODO 6 死锁 DEADLOCK
*** TODO 1. 资源
*** TODO 2. 介绍死锁
*** TODO 3. 鸵鸟算法
*** TODO 4. 死锁发现和恢复
*** TODO 5. 死锁的避免
*** TODO 6. 死锁的预防
*** TODO 7. 其它问题
*** TODO 8. 探索死锁
*** TODO 9. 总结
** TODO 7 虚拟化和云
*** TODO 1. 历史
*** TODO 2. 虚拟化的要求
*** TODO 3. 类型1和类型2的HYPERVISORS
*** TODO 4. 高效虚拟化性能
*** TODO 5. 管理微内核做对了吗？
*** TODO 6. 内存虚拟
*** TODO 7. IO 虚拟
*** TODO 8. 程序虚拟
*** TODO 9. 在多核CPU上虚拟机器
*** TODO 10. 许可证问题
*** TODO 11. 云
*** TODO 12. 学习案例：VMSARE
*** TODO 13. 探索虚拟化和云
** TODO 8 多进程系统
*** TODO 1. 多进程
*** TODO 2. 多计算机
*** TODO 3. 分布式系统
*** TODO 4. 探索多进程系统
*** TODO 5. 总结
** TODO 9 安全
*** TODO 1. 安全环境
*** TODO 2. 操作系统安全
*** TODO 3. 控制进入资源
*** TODO 4. 安全系统的正式模型
*** TODO 5. 密码学基础
*** TODO 6. 验证
*** TODO 7. 压榨系统
*** TODO 8. 内部攻击
*** TODO 9. MALWARE 
*** TODO 10. 防御
*** TODO 11. 探索安全
*** TODO 12. 总结
** TODO 10 案例学习 1: UNIX,LINUX,和ANDROID 
*** TODO 1. UNINX AND LINUX 历史
*** TODO 2. LINUX 概览
*** TODO 3. LINUX 进程
*** TODO 4. LINUX 内存管理
*** TODO 5. LINUX 输入/输出
*** TODO 6. LINUX 文件系统
*** TODO 7. LINUX 安全
*** TODO 8. ANDROID
*** TODO 9. 总结
** TODO 11 安全学习 2: WINDOWS 8
*** TODO 1. WINDOWS 到 WINDOWS 8.1 的历史
*** TODO 2. WINDOWS 编程
*** TODO 3. 文件构造
*** TODO 4. WINDOWS 进程和线程
*** TODO 5. 内存管理
*** TODO 6. WINDOWS 缓存
*** TODO 7. WINDOWS 输入输出
*** TODO 8. WINDOWS NT 文件系统
*** TODO 9. WINDOWS 电源管理
*** TODO 10. WINDOWS 8 安全
*** TODO 11. 总结
** TODO 12 操作系统设计
*** TODO 1. 设计问题的自然
*** TODO 2. 界面设计
*** TODO 3. 实现
*** TODO 4. 性能
*** TODO 5. 工程管理
*** TODO 6. 操作系统设计趋势
*** TODO 7. 总结
** TODO 13 阅读 LIST 和 参考书目
*** TODO 1. 建议阅读
*** TODO 2. 参考书目 
